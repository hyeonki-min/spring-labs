# 📘 Rate Limiter Overview  
자바 기반 처리율 제한 알고리즘 정리

---

## 🏁 1. 소개

처리율 제한(Rate Limiting)은 **특정 시간 동안 허용할 수 있는 요청 수를 제어하여 시스템을 보호하는 기법**이다.

API 요청 폭주, 봇/스크래핑, 트래픽 스파이크 완화, 외부 API 호출 제한 등  
백엔드 시스템에서 필수적으로 사용된다.

본 문서에서는 자바 기반으로 구현 가능한 대표적인 5가지 알고리즘을 설명하며,  
각 방식의 특징·장점·단점을 비교한다.

---

## 🧭 2. Rate Limiting이 필요한 이유

- 외부 API 제공자가 초당 요청 제한을 두고 있을 때
- 데이터베이스 / 외부 서비스 / GPU inference 등 다운스트림 보호
- 악성 트래픽 차단
- 봇·스크립트 공격 방지
- 스파이크 트래픽으로 인한 장애 방지
- API 공정성(Fairness) 확보

---

# 🧪 3. 주요 알고리즘 요약

본 문서에서 다루는 대표 알고리즘:

1. **Token Bucket (토큰 버킷)**  
2. **Leaky Bucket (누출 버킷)**  
3. **Fixed Window Counter (고정 윈도 카운터)**  
4. **Sliding Window Counter (슬라이딩 윈도 카운터)**  
5. **Sliding Window Log (슬라이딩 윈도 로그)**

각 알고리즘은 성능·정확도·버스트 처리 방식이 다르므로  
요구사항에 맞는 설계가 필요하다.

---

# 🪣 4. Token Bucket (토큰 버킷)

### 📌 개념
- “토큰이 채워지는 양동이” 모델  
- 토큰이 일정 속도로 채워지고, 요청 시 토큰을 소비한다.

### 📌 특징
- 버스트 트래픽 허용  
- 평균 처리율(rate)을 정확히 제어  
- 한동안 요청이 없으면 토큰이 쌓여 초반에 많은 요청 허용 가능

### 📌 장점
- 매우 유연하고 실무에서 널리 사용  
- API Gateway, 사용자별 제한 등에 적합

### 📌 단점
- “초당 정확히 N건”과는 약간의 차이가 발생할 수 있음  
- 분산 환경에서는 atomic 업데이트 필요

---

# 💧 5. Leaky Bucket (누출 버킷)

### 📌 개념
- 요청을 큐에 쌓아두고 **일정한 속도로만** 소비하는 모델  
- FIFO queue 기반

### 📌 특징
- 다운스트림 보호에 매우 효과적  
- 장기적 스파이크 완화 (트래픽 평탄화)

### 📌 장점
- 일정한 처리율 유지  
- GPU inference, 외부 API 호출 등 Block 기반 처리와 궁합이 좋음

### 📌 단점
- 즉각적인 응답이 중요한 API에는 적합하지 않음  
- 큐가 꽉 차면 drop 필요

---

# 🪟 6. Fixed Window Counter (고정 윈도 카운터)

### 📌 개념
- “정해진 구간마다 카운터를 리셋”하는 단순한 방식  
예: 12:00:01.000 ~ 12:00:01.999 동안 최대 10건 허용

### 📌 특징
- 구현 쉽고 속도 빠름

### 📌 장점
- Redis INCR + EXPIRE로 매우 쉽게 구현  
- 내부 API 제한 등 간단한 용도에 적합

### 📌 단점
- **경계(burst) 문제**  
  - 구간 경계 직전에 10건, 직후에 10건 → 순간적으로 20건 허용할 수 있음

---

# 📊 7. Sliding Window Counter (슬라이딩 윈도 카운터)

### 📌 개념
- 고정 윈도 버스트 문제를 해결하기 위해  
  **이전 윈도와 현재 윈도 요청 수를 시간 비율에 따라 가중 합산**하는 방식

### 📌 특징
- 성능은 매우 우수  
- 정확도는 Sliding Log보다는 떨어지지만 실용적

### 📌 장점
- 정확도와 성능 균형 우수  
- 대부분의 백엔드 서버에서 사용 가능

### 📌 단점
- 완전히 정확한 슬라이딩은 아니고 근사치  
- 여러 윈도를 뛰어넘는 경우 previousCount 무효화

---

# 📑 8. Sliding Window Log (슬라이딩 윈도 로그)

### 📌 개념
- 요청이 들어올 때마다 timestamp 저장  
- “현재 시간 - 윈도 우측 경계” 이전의 timestamp를 모두 제거  
- 남아있는 timestamp 수가 window 내 정확한 요청 수가 된다

### 📌 특징
- **정확도 최고**  
- 완전한 Sliding Window 구현

### 📌 장점
- 초당 N건을 정확히 지키는 API에 필수  
- 금융/보안/Strict API 제한에 적합

### 📌 단점
- timestamp 저장 비용 증가  
- 요청량이 많으면 삭제 비용 존재  
- Sorted Set 또는 Deque 구현 필요

---

# ⚖️ 9. 알고리즘 비교표

| 알고리즘 | 정확도 | 성능 | 버스트 처리 | 주요 특징 |
|---------|--------|--------|--------------|------------|
| Token Bucket | 중~높음 | 높음 | 허용 | 평균 처리율 조절 + 버스트 허용 |
| Leaky Bucket | 중 | 높음 | 거의 없음 | 일정한 소비율, 트래픽 평탄화 |
| Fixed Window Counter | 낮음 | 매우 높음 | 경계 버스트 있음 | 구현 가장 단순 |
| Sliding Window Counter | 중~높음 | 높음 | 버스트 완화 | 시간 가중 보간 |
| Sliding Window Log | 최고 | 중 | 최소화 | 완전한 슬라이딩 정확도 |

---

# 🎯 10. 알고리즘 선택 가이드

### ✔ “정확히 초당 N건 제한이 필요함”
→ **Sliding Window Log**

### ✔ 평균 처리율 + 버스트 트래픽 허용 필요
→ **Token Bucket**

### ✔ 다운스트림 보호 / 일정한 처리율 유지가 목표
→ **Leaky Bucket**

### ✔ 단순 구현이 최우선
→ **Fixed Window Counter**

### ✔ 고정 윈도보다 정확하고 로그 방식보다 가벼운 균형형
→ **Sliding Window Counter**

---

# 🌐 11. 분산 환경 고려사항

- 여러 서버 인스턴스가 동일한 key에 대해 요청을 처리하는 경우  
  로컬 메모리 기반 rate limiter는 정확하게 동작하지 않는다.

분산 환경에서는 다음이 필요하다:

- Redis / Memcached / Shared Cache  
- Lua Script 기반 atomic 연산  
- TTL 관리  
- Fail-open / Fail-closed 정책  
- Rate Limiter 장애 시 fallback 정책

---

# 🔍 12. 결론

Rate Limiting은 단순한 기능처럼 보이지만  
**정확도, 성능, 비용, 시스템 특성, 운영 전략이 종합적으로 고려되어야 하는 설계 요소**이다.

각 알고리즘은 다음과 같은 뚜렷한 목적을 갖는다:

- **Token Bucket** → 버스트 허용 + 평균 제어  
- **Leaky Bucket** → 일정한 소비율 유지  
- **Fixed Window** → 초간단 구현  
- **Sliding Window Counter** → 정확도·성능 균형  
- **Sliding Window Log** → 최고 정확도 슬라이딩 윈도우

서비스 특성에 가장 적합한 방식을 선택하는 것이 중요하다.

---
